<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OBS Source Display (Echtzeit)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Wichtig: Transparenter Hintergrund für OBS */
        body {
            background-color: transparent;
            overflow: hidden; 
            color: white; 
            font-family: 'Inter', sans-serif;
        }
        .source-container {
            /* 100% of the OBS Browser Source's resolution */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .display-item {
            position: absolute;
            box-sizing: border-box;
            word-wrap: break-word;
            transition: opacity 0.3s ease; 
            will-change: transform, left, top, width, opacity; 
        }
        .text-content {
            white-space: pre-wrap; 
            overflow: hidden;
            display: flex;
            align-items: center; 
            justify-content: center; 
            height: 100%; 
            /* OBS needs a separate background style for the container to respect alpha */
        }
        .browser-source iframe {
            width: 100%;
            height: 100%;
            border: none;
            background-color: transparent;
        }
        .media-source, .timer-source {
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            height: 100%;
        }
        .media-source img, .media-source video {
            width: 100%;
            height: 100%;
            object-fit: contain; 
        }
        
        /* Loading Message Style */
        #loadingMessage {
             font-family: 'Inter', sans-serif;
             z-index: 9999;
        }
    </style>
</head>
<body>
    <div id="sourceContainer" class="source-container">
        <!-- Dynamic sources will be injected here -->
    </div>
    <div id="loadingMessage" class="absolute inset-0 flex items-center justify-center bg-gray-900 bg-opacity-75 text-xl font-bold text-white">
        Lade Echtzeit-Konfiguration...
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- HARDCODED CONFIG FOR EXTERNAL SERVER ---
        const firebaseConfig = {
            apiKey: "AIzaSyCfam-57aK-bqyeyK1t-uAIriBcO4MzAlw",
            authDomain: "obs-sources.firebaseapp.com",
            projectId: "obs-sources",
            storageBucket: "obs-sources.firebasestorage.app",
            messagingSenderId: "237195798184",
            appId: "1:237195798184:web:5dfc432b70c3377b74849d",
        };
        

        // --- Firebase Initialization and Configuration ---
        
        const container = document.getElementById('sourceContainer');
        const loadingMessage = document.getElementById('loadingMessage');
        let db;
        let activeSources = [];
        let timerInterval = null;

        // CONSTANT PATH for Firestore (based on projectId "obs-sources")
        const DB_PATH = `artifacts/obs-sources/public/data/obs_state`;
        const DOC_ID = 'live_config';

        async function initFirebase() {
            try {
                if (!firebaseConfig.apiKey) {
                    throw new Error("Fehler: Firebase-Konfiguration oder API-Schlüssel fehlt.");
                }

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                const auth = getAuth(app);

                // EXTERNAL: Sign in anonymously
                await signInAnonymously(auth);
                
                startRealtimeListener();
                loadingMessage.classList.add('hidden'); 

            } catch (error) {
                console.error("Firebase Initialisierungsfehler:", error);
                loadingMessage.textContent = `Echtzeit-FEHLER: ${error.message}. Ist der API-Schlüssel korrekt und anonyme Anmeldung erlaubt?`;
                loadingMessage.style.backgroundColor = 'rgba(255, 0, 0, 0.9)';
            }
        }

        // --- Utility Functions ---

        /** Converts HEX color and Alpha value to RGBA string. */
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.substring(1, 3), 16);
            const g = parseInt(hex.substring(3, 5), 16);
            const b = parseInt(hex.substring(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        /** Formats total seconds into hh:mm:ss. */
        function formatTime(totalSeconds) {
            const absSeconds = Math.floor(Math.abs(totalSeconds));
            const sign = totalSeconds < 0 ? "-" : "";
            const h = Math.floor(absSeconds / 3600);
            const m = Math.floor((absSeconds % 3600) / 60);
            const s = absSeconds % 60;

            const parts = [];
            if (h > 0) parts.push(String(h).padStart(2, '0'));
            parts.push(String(m).padStart(2, '0'));
            parts.push(String(s).padStart(2, '0'));
            
            return sign + parts.join(':');
        }

        /** Calculates elapsed time since the last timer update (Start/Pause/Reset). */
        function calculateCurrentDisplayTime(source) {
            const durationSeconds = source.initialDuration || 0;
            
            if (!source.isRunning || source.startTime === 0) {
                // Timer is paused or reset: show initial duration (countdown) or 0 (countup)
                return source.timerMode === 'countdown' ? durationSeconds : 0;
            } 
            
            // Running Timer: calculate elapsed time
            const elapsedSeconds = (Date.now() - source.startTime) / 1000;
            
            if (source.timerMode === 'countdown') {
                let remainingSeconds = durationSeconds - elapsedSeconds;
                
                if (remainingSeconds < 0) {
                    remainingSeconds = 0;
                    // Auto-stop the timer in the display
                    source.isRunning = false;
                    // Trigger a save to update the control panel state
                    if (db) setDoc(doc(db, DB_PATH, DOC_ID), { sources: activeSources.map(s => s.id === source.id ? source : s) }, { merge: true });
                }
                return remainingSeconds;
            } else { 
                // countup
                return elapsedSeconds;
            }
        }

        /** Updates all timer displays. */
        function updateTimerDisplays() {
            activeSources.forEach(source => {
                if (source.type !== 'timer' || !source.visible) return; 
                
                const timerElement = document.getElementById(`item-${source.id}`);
                const display = timerElement ? timerElement.querySelector('.timer-display') : null;
                if (!display) return;
                
                const displayTime = calculateCurrentDisplayTime(source);
                display.textContent = formatTime(displayTime);
            });
            
            // Check if any timer is still running; if not, clear the interval
            if (!activeSources.some(s => s.type === 'timer' && s.isRunning)) {
                if (timerInterval) clearInterval(timerInterval);
                timerInterval = null;
            }
        }


        /** Renders the sources based on the state data. */
        function renderSources(sources) {
            container.innerHTML = '';
            
            activeSources = sources.filter(s => s.visible).sort((a, b) => a.order - b.order);
            
            // Stop old timer intervals
            if (timerInterval && !activeSources.some(s => s.type === 'timer' && s.isRunning)) {
                clearInterval(timerInterval);
                timerInterval = null;
            }


            activeSources.forEach(source => {
                const el = document.createElement('div');
                el.id = `item-${source.id}`;
                el.className = 'display-item p-2 rounded';
                
                // Base Styling
                el.style.left = `${source.x}%`;
                el.style.top = `${source.y}%`;
                el.style.width = `${source.w}%`;
                el.style.height = `${source.h}%`;
                el.style.transform = `scale(${source.s})`;
                el.style.transformOrigin = 'top left';
                el.style.zIndex = source.order;
                
                // Background color (if specified)
                const bgColorRgba = hexToRgba(source.bgColor || '#000000', source.bgAlpha || 0.0);
                el.style.backgroundColor = bgColorRgba;


                // Content and specific styling
                if (source.type === 'text') {
                    el.className += ' text-content';
                    el.style.color = source.color || 'white';
                    el.style.fontSize = `${source.size || 2}rem`;
                    el.style.textAlign = source.textAlign || 'left';
                    el.textContent = source.content;
                } else if (source.type === 'media') {
                    el.className += ' media-source';
                    el.style.padding = '0';
                    const url = source.content.toLowerCase();
                    
                    let mediaElement;
                    if (url.match(/\.(mp4|webm|ogg|mov)$/i)) {
                        mediaElement = document.createElement('video');
                        mediaElement.autoplay = true;
                        mediaElement.loop = true;
                        mediaElement.muted = true;
                        mediaElement.src = source.content;
                    } else {
                        mediaElement = document.createElement('img');
                        mediaElement.src = source.content;
                        mediaElement.onerror = () => { /* Handle image load error silently in OBS */ };
                    }
                    mediaElement.className = 'w-full h-full object-contain';
                    el.appendChild(mediaElement);

                } else if (source.type === 'timer') {
                    el.className += ' timer-source text-content';
                    el.style.color = source.color || '#ffcc00';
                    el.style.fontSize = `${source.size || 5}rem`;
                    
                    // Initial rendering uses the saved state
                    const initialDisplayTime = calculateCurrentDisplayTime(source);
                    el.innerHTML = `<div class="timer-display">${formatTime(initialDisplayTime)}</div>`;

                } else if (source.type === 'browser') {
                    el.className += ' browser-source';
                    el.style.backgroundColor = 'transparent';
                    el.style.padding = '0';
                    const iframe = document.createElement('iframe');
                    iframe.src = source.content;
                    iframe.allow = "autoplay; fullscreen; microphone; camera";
                    el.appendChild(iframe);
                }

                container.appendChild(el);
            });
            
            // Start the timer interval if running timers exist
            if (!timerInterval && activeSources.some(s => s.type === 'timer' && s.isRunning)) {
                 updateTimerDisplays(); // Immediate update
                 timerInterval = setInterval(updateTimerDisplays, 1000);
            } else if (activeSources.some(s => s.type === 'timer')) {
                 // Update static timer displays (paused/reset)
                 updateTimerDisplays();
            }
        }

        // --- Firestore Listener ---

        /** Starts the real-time listener for the configuration. */
        function startRealtimeListener() {
            const docRef = doc(db, DB_PATH, DOC_ID);

            onSnapshot(docRef, (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const state = docSnapshot.data();
                    const sources = state.sources || [];
                    renderSources(sources);
                } else {
                    renderSources([]);
                }
            }, (error) => {
                console.error("Fehler beim Abrufen des Echtzeit-Zustands:", error);
                loadingMessage.textContent = `Echtzeit-FEHLER: ${error.message}`;
                loadingMessage.style.backgroundColor = 'rgba(255, 0, 0, 0.9)';
            });
        }

        window.onload = initFirebase;
    </script>
</body>
</html>